<!-- configure.html -->
<!-- 
  A Node configuration page: you can add new nodes (IP:port) or remove them,
  see if they respond to /ping. 
  This is relevant for establishing your network's nodes.
-->

<!DOCTYPE html>
<html lang="en">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>Blockchain Node - Configure</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">
  <style>
    .online-indicator {
      display: inline-block;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      margin-right: 8px;
      vertical-align: middle;
    }
    .online {
      background-color: green;
    }
    .offline {
      background-color: red;
    }
  </style>
</head>
<body class="bg-light">

<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
  <a class="navbar-brand" href="/">Blockchain Node</a>

  <button class="navbar-toggler" type="button" 
          data-bs-toggle="collapse"
          data-bs-target="#navbarSupportedContent"
          aria-controls="navbarSupportedContent"
          aria-expanded="false"
          aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <ul class="navbar-nav ms-auto">
      <li class="nav-item">
        <a class="nav-link" href="/">Node Dashboard</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="/configure">Configure 
          <span class="visually-hidden">(current)</span>
        </a>
      </li>
    </ul>
  </div>
</nav>

<div class="container mt-5">
  <h2>Node configuration</h2>
  <p>Add/remove nodes, check if they are online (/ping)</p>

  <div class="row g-4">
    <div class="col-lg-6">
      <div class="card shadow-sm">
        <div class="card-body">
          <h4 class="card-title">Nodes</h4>
          <p class="card-text">Manage known peers that participate in gossip and syncing.</p>

          <div class="mb-3">
            <label class="form-label" for="nodesInput">Node URLs (comma-separated):</label>
            <input type="text" id="nodesInput" class="form-control"
                   placeholder="e.g. 192.168.1.11:5000, 192.168.1.12:5000">
          </div>
          <button id="addNodesBtn" class="btn btn-primary">Add nodes</button>

          <hr>
          <ul id="nodesList" class="list-group"></ul>
        </div>
      </div>
    </div>

    <div class="col-lg-6">
      <div class="card shadow-sm">
        <div class="card-body">
          <h4 class="card-title">Trusted validators</h4>
          <p class="card-text">Promote validators to the trusted set to enable block approval.</p>

          <div class="mb-3">
            <label class="form-label" for="trustedNodesInput">Trusted node URLs (comma-separated):</label>
            <input type="text" id="trustedNodesInput" class="form-control"
                   placeholder="e.g. validator.example.com:6000">
          </div>
          <button id="addTrustedNodesBtn" class="btn btn-success">Add trusted nodes</button>

          <hr>
          <ul id="trustedNodesList" class="list-group"></ul>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.0/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script>
async function loadNodes() {
  try {
    const resp = await fetch('/nodes/get');
    if (!resp.ok) throw new Error("Fetch /nodes/get failed");
    const data = await resp.json();
    const nodeArray = data.total_nodes || [];

    const nodesList = document.getElementById('nodesList');
    nodesList.innerHTML = '';

    if (nodeArray.length === 0) {
      nodesList.innerHTML = "<li class='list-group-item'>No nodes</li>";
      return;
    }

    nodeArray.forEach(node => {
      const li = document.createElement('li');
      li.className = 'list-group-item d-flex justify-content-between align-items-center';

      // A small circle to show offline/online
      const indicator = document.createElement('span');
      indicator.className = 'online-indicator offline';

      const textSpan = document.createElement('span');
      textSpan.textContent = node;

      const removeBtn = document.createElement('button');
      removeBtn.className = 'btn btn-danger btn-sm';
      removeBtn.textContent = 'Remove';
      removeBtn.addEventListener('click', () => {
        removeNode(node);
      });

      li.appendChild(indicator);
      li.appendChild(textSpan);
      li.appendChild(removeBtn);
      nodesList.appendChild(li);

      checkNodeOnline(node, indicator);
    });

  } catch(e) {
    alert("Unable to load nodes: " + e);
  }
}

async function removeNode(node) {
  try {
    const r = await fetch('/nodes/remove', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ node })
    });
    const resp = await r.json().catch(() => ({}));
    if (!r.ok) {
      const message = resp && resp.message ? resp.message : 'Error removing node';
      throw new Error(message);
    }
    alert(resp.message || 'Node removed');
    loadNodes();
  } catch(err) {
    alert("Error removing node: " + err.message);
  }
}

async function loadTrustedNodes() {
  try {
    const resp = await fetch('/trusted_nodes/get');
    if (!resp.ok) throw new Error("Fetch /trusted_nodes/get failed");
    const data = await resp.json();
    const trustedNodes = data.trusted_nodes || [];

    const trustedList = document.getElementById('trustedNodesList');
    trustedList.innerHTML = '';

    if (trustedNodes.length === 0) {
      trustedList.innerHTML = "<li class='list-group-item'>No trusted nodes</li>";
      return;
    }

    trustedNodes.forEach(node => {
      const li = document.createElement('li');
      li.className = 'list-group-item d-flex justify-content-between align-items-center';

      const indicator = document.createElement('span');
      indicator.className = 'online-indicator offline';

      const textSpan = document.createElement('span');
      textSpan.textContent = node;

      const removeBtn = document.createElement('button');
      removeBtn.className = 'btn btn-danger btn-sm';
      removeBtn.textContent = 'Remove';
      removeBtn.addEventListener('click', () => {
        removeTrustedNode(node);
      });

      li.appendChild(indicator);
      li.appendChild(textSpan);
      li.appendChild(removeBtn);
      trustedList.appendChild(li);

      checkNodeOnline(node, indicator);
    });
  } catch (e) {
    alert("Unable to load trusted nodes: " + e);
  }
}

async function addTrustedNodes(nodes) {
  const resp = await fetch('/trusted_nodes/register', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ nodes })
  });
  const payload = await resp.json().catch(() => ({}));
  if (!resp.ok) {
    const message = payload && payload.message ? payload.message : 'Unable to add trusted nodes';
    throw new Error(message);
  }
  return payload;
}

async function removeTrustedNode(node) {
  try {
    const resp = await fetch('/trusted_nodes/remove', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ node })
    });
    const payload = await resp.json().catch(() => ({}));
    if (!resp.ok) {
      const message = payload && payload.message ? payload.message : 'Error removing trusted node';
      throw new Error(message);
    }
    alert(payload.message || 'Trusted node removed');
    loadTrustedNodes();
  } catch (err) {
    alert("Error removing trusted node: " + err.message);
  }
}

function checkNodeOnline(node, indicatorElement) {
  let url = node.trim();
  if (!(url.startsWith("http://") || url.startsWith("https://"))) {
    url = "http://" + url;
  }
  url += "/ping";

  console.log("Ping =>", url);

  fetch(url)
    .then(res => {
      console.log("ping response =>", res.status);
      if (!res.ok) throw new Error("Ping status: " + res.status);
      return res.json();
    })
    .then(json => {
      console.log("ping json =>", json);
      if (json.status === "OK") {
        indicatorElement.classList.remove('offline');
        indicatorElement.classList.add('online');
      }
    })
    .catch(err => {
      console.warn("ping error =>", err);
    });
}

function parseNodeInput(raw) {
  return raw
    .split(',')
    .map(item => item.trim())
    .filter(item => item.length > 0);
}

document.addEventListener('DOMContentLoaded', () => {
  const addNodesBtn = document.getElementById('addNodesBtn');
  const nodesInput  = document.getElementById('nodesInput');
  const addTrustedNodesBtn = document.getElementById('addTrustedNodesBtn');
  const trustedNodesInput = document.getElementById('trustedNodesInput');

  addNodesBtn.addEventListener('click', async () => {
    const raw = nodesInput.value.trim();
    if (!raw) {
      alert("Please provide at least one IP:port");
      return;
    }
    const arr = parseNodeInput(raw);

    try {
      const resp = await fetch('/nodes/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ nodes: arr })
      });
      const payload = await resp.json().catch(() => ({}));
      if (!resp.ok) {
        const message = payload && payload.message ? payload.message : 'Node register error';
        throw new Error(message);
      }
      alert(payload.message || 'Nodes added');
      nodesInput.value = '';
      loadNodes();
    } catch (e) {
      alert("Error adding nodes: " + e.message);
    }
  });

  addTrustedNodesBtn.addEventListener('click', async () => {
    const raw = trustedNodesInput.value.trim();
    if (!raw) {
      alert("Please provide at least one trusted node");
      return;
    }

    const nodes = parseNodeInput(raw);
    if (nodes.length === 0) {
      alert("Please provide at least one trusted node");
      return;
    }

    try {
      const resp = await addTrustedNodes(nodes);
      alert(resp.message || 'Trusted nodes added');
      trustedNodesInput.value = '';
      loadTrustedNodes();
    } catch (err) {
      alert(err.message);
    }
  });

  loadNodes();
  loadTrustedNodes();
});
</script>
</body>
</html>
